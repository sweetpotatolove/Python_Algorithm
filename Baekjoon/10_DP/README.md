## 파이썬 리스트 복사
### 🔹`[[0, 0]] * N` vs `[[0, 0] for _ in range(N)]`

📌 핵심 개념: 리스트는 '값'이 아니라 주소(참조) 를 담는다

#### ❌ 잘못된 초기화 예시
```python
memo = [[0, 0]] * 3
```
- `[[0, 0]]`라는 하나의 리스트 객체를 3번 참조한 것
- 즉, `memo[0]`, `memo[1]`, `memo[2]`는 전부 같은 객체(같은 주소)를 가리킴
  - ex. 현재 `[[101호], [101호], [101호]]` 상태

#### ⚠️ 여기서 주의할 점
1. 값을 넣으면 -> 전부 바뀜
    ```python
    memo[0][0] = 999
    print(memo)  # [[999, 0], [999, 0], [999, 0]]
    ```
    - `memo[0][0] = 999`는 101호에 값을 넣는 행위
    - 그런데 `memo[1]`, `memo[2]`도 101호이므로, 전부 함께 바뀜

2. 리스트 자체를 통째로 바꾸면? -> 새 주소로 교체됨
    ```python
    memo[0] = [1, 2]
    print(memo)  # [[1, 2], [0, 0], [0, 0]]
    ```
    - `memo[0] = [1, 2]`는 101호 주소 자체를 아예 201호(`[1, 2]`)로 바꾸는 행위
    - 이 경우, `memo[0]`만 새 주소를 참조하게 되고, 나머지는 여전히 101호
    - 즉, `[[201호], [101호], [101호]]`

#### ✅ 올바른 초기화 방법
```python
memo = [[0, 0] for _ in range(3)]
```
- 이 코드는 [0, 0]이라는 리스트를 3개 각각 새로 생성
- 각 리스트는 서로 다른 주소를 가지므로 안전하게 사용 가능

#### 💬 결론
- `*` 연산자는 얕은 복사(shallow copy) 를 하므로 내부 리스트가 모두 같은 주소를 가리킴
  - 값을 바꾸면 다 같이 바뀌고,
  - 리스트를 새로 할당하면 해당 위치의 주소만 바뀜
- 이차원 리스트 초기화할 땐 항상 `[[0, 0] for _ in range(N)]`처럼 반복문을 사용한 방식이 안전함

