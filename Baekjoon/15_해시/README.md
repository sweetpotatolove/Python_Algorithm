## 🔹 리스트 vs 딕셔너리 시간복잡도 정리
### 📂 리스트 (list)
| 연산                     | 시간 복잡도      |
| ---------------------- | ----------- |
| 인덱스로 원소 접근 (`lst[i]`)  | O(1)        |
| 맨 뒤에 추가 (`append`)     | O(1)        |
| 맨 앞/중간 삽입 (`insert`)   | O(N)        |
| 원소 탐색 (`x in lst`)     | O(N)        |
| 특정 원소 삭제 (`remove(x)`) | O(N)        |
| pop (맨 뒤/앞)            | O(1) / O(N) |
| 정렬 (`sort()`)          | O(N log N)  |

- 리스트에서 어떤 값을 찾는 작업은 항상 `O(N)`
- 대량의 검색 작업이 있을 땐 list보다 dict가 유리

### 📂 딕셔너리 (dict)
| 연산                      | 시간 복잡도 (평균) | 시간 복잡도 (최악) |
| ----------------------- | ----------- | ----------- |
| 값 삽입 (`d[key] = value`) | O(1)        | O(N)        |
| 값 조회 (`d[key]`)         | O(1)        | O(N)        |
| 값 삭제 (`del d[key]`)     | O(1)        | O(N)        |
| 키 존재 확인 (`key in d`)    | O(1)        | O(N)        |

- 대부분의 경우 평균적으로 매우 빠름 (`O(1)`)
- **충돌(collision)** 이 심한 경우 최악은 O(N) 가능하지만, 파이썬 내부 구현이 잘 되어 있어 실제로 거의 발생하지 않음

### 언제 어떤 자료구조 써야할까?
| 상황                    | 추천 자료구조         |
| --------------------- | --------------- |
| 원소가 순서대로만 필요          | `list`          |
| 값의 존재 여부를 자주 확인해야 할 때 | `set` 또는 `dict` |
| 키-값 쌍으로 빠르게 조회        | `dict`          |
| 반복 탐색이 많고 중복 제거 필요    | `dict` 또는 `set` |

### ✅ 예시: 비밀번호 찾기 (백준 17219)
```python
# 비효율적인 방법 (list)
for site in site_list:
    for pair in password_list:
        if pair[0] == site:
            print(pair[1])  # O(N * M)

# 효율적인 방법 (dict)
for site in site_list:
    print(password_dict[site])  # O(M)
```